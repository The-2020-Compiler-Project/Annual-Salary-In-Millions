## 第二次过程报告

计算机1803-钟洁-20184333

这周的工作主要是完成了和前端的对接，以及基本块划分，基本块内四元式的优化，重组四元式和输出优化后的四元式的代码实现，现已完成与前端的链接，能够输出正确的结果。由于自己的粗心大意和逻辑不够严谨，同时因为仅在四元式结构确定后就开始实现，代码出现了很多问题，花了一天的时间去debug，浪费了很多时间。

##### 1.主要变量和结构

int dagnum = 0;//用来记录每个基本块生成的结点个数

int nodevalue = 0;//用来记录已存在的变量和常数的个数

vector<QUATERNION> QT;//用来存储优化后的四元式

vector<OPERAND> node_list; //用来存储已存在的变量和常数

vector<Dnode>NODE;//用来存储一个基本块内的结点信息

struct Dnode {	//结点信息结构体

  int num; //节点编号

  bool isLeaf; //叶节点

  bool iscval; //是常数

  int lchild;//左孩子所在结点的编号

  int rchild;//右孩子所在结点的编号

  SIGN oper; //运算符

  int label_num;

  OPERAND label[10]; //该结点的主从标记

  Dnode();

};

Dnode::Dnode()

{

  isLeaf = true;

  iscval = false;

  label_num = 0;

}

相比上周确定的结构体，对其进行了一定的调整，由于前端没有做单目运算的处理，所以删除了用于判断是单目运算还是双目运算的bool single;之前是用指针数组来存储基本块每个结点的，但由于对于指针的不熟练以及类型不匹配等原因导致优化后的四元式无法输出，所以改成了结构体向量的形式存储，将lchild和rchild由原来的的指针改为了变量，存储的是左右孩子在NODE的下标。

#### 2.主要函数

**①void divide(); //划分基本块;**

 我们的四元式存储在结构体向量quaternion_list中，每个基本块的所有节点信息存在结构体向量NODE中，变量和常量信息存在结构体向量node_list，所以开始一个新的基本块的时候要对NODE,node_list,dagnum,nodevalue进行初始化，清空。

基本块划分时主要是判断四元式的符号是否是跳转语句ie,else,do,wh,we,if等，不是就读取下一个四元式；是就表示一个基本块的结束，它的下一条语句是另一个基本块的开始。调用optimize(start, end)函数，对跳转语句前的四元式构建DAG图，再调用opti_Quaternion()函数通过DAG图生产优化后的四元式保存在QT中，最后将跳转语句加入QT中。

这一块处理的时候出现了两个问题：

①由于一个基本块结束后，我将end指向跳转语句的下一条指令，然后for循环读下一个四元式时将end的值赋给start，表示新的基本块的开始。但是出现了（we, __ , __ ,_ __ ,)和（ie,  __  , __ ,__,)挨在一起的情况，此时ie作为基本块唯一的四元式，调用optimize(start, end)就出现了问题，所以就在调用optimize(start, end)和opti_Quaternion()前进行了判断，如果start=end就直接将该四元式加入QT，否则要进行四元式的优化。

②由于我是通过跳转语句来确定基本块语句的结束的，但是如果没有跳转语句，那么他只会继续读取下一个四元式而不进入优化，所以在函数结束的时候我们添加了一个四元式（end, __ , __ ,_ __ ,)来表示函数的结束，然后以他作为一个基本块的结束进入优化。

**②int isdefine(string op); //判断op是否被定义过**

这个函数主要是为了判读操作数是否已经被定义过了，是的话返回其在node_list的位置，便于后续的删除工作，如果不是的话就返回-1.

**③int innode(string op); //op在node_list的位置**

这个函数主要是为了获得其在node_list中的位置，因为在node_list中，操作数的位置存储的是其在图中的结点的编号，当该操作数已存在后，我们需要删除它之前的位置，然后将它的position改为现在的结点的编号。

**④void opti_Quaternion(); //生成优化后的四元式**

通过遍历图中的每个结点，判断其是否是叶子节点，如果不是的话要构成双目运算的四元式，以它的运算符作为四元式的运算符，以它的第一个标记作为四元式的第三个操作数。左孩子所在结点的第一个标记作为四元式的第一个操作数，右孩子所在结点的第一个标记作为四元式的第二个操作数。无论是否是叶子节点，都需要遍历其从标记，如果他的从标记不是临时变量，则要生成赋值四元式，将主标记的值赋给该从标记。

由于没有和四元式生成的同学了解清楚，赋值语句的第二个操作数我存的是"_",但是四元式生成的同学其实是没有对其进行处理和保存的，就只是“ ”，所以这里出了一点小问题。

**⑤bool istemp(OPERAND temp); //是否是临时变量**

该函数是为了判断该操作数是否是临时变量，因为如果主标记是临时变量，是需要交换其和从标记的位置的。之前我是采用的访问符号表获取该变量的类型，测试之后发现得到的结果不正确，和生成四元式的同学沟通后了解到他在生成四元式时对结果是常数的临时变量进行了处理，将他的类型改为了常数。由于前端已经链接好，所以在不改动前端的情况下我采用了另一种方式来判断，我们的临时变量的名字为了和标识符区分开，采用的是“数字t”这种，所以只需要判断该操作数第一个字符是否是数字，最后一个字符是否是‘t'即可，是返回true，否则返回false。

**⑥bool iscv(OPERAND op); //是否是常数**

该函数主要是判断操作数是否是常数，在进行双目运算的优化时，如果他的两个操作数都是常数，就不需要构建左右孩子，只用生成一个结点保存运算结果和第三个操作数。

**⑦void del(OPERAND res, int newnum, int oldnum); //删除该结果的其他位置**

如果操作数res是之前已经定义过的，我们需要将它从原来结点的标记中删除（主标记免删），同时通过调用innode()函数获得它在node_list中的位置，改变它的位置为现在的结点的编号。此处在测试过程中也出现了一些问题，就是我仅仅将其从原结点的标记中删除了，但是忘记了改变原结点的标记个数，让其个数减1后就正常了。

**⑧void optimize(int start, int end); //DAG优化**

此函数是对基本块内的四元式优化，通过for循环遍历基本块内的每个四元式，如果他的运算符是“=”，那么就调用fuzhi ()函数进行处理，如果不是就调用binaryoperator()函数进行双目运算符的处理（因为前端没有做单目运算符）。

**⑨void fuzhi(OPERAND op, OPERAND res); //赋值四元式**

该函数是对赋值四元式的处理，先通过isdefine()函数判断第一个操作数和第三个操作数是否已被定义过。如果第一个数没有被定义过，就建立一个结点（加入NODE中），他的编号为当前dagnum值，是叶子结点，主标记为它自己，从标记为第三个操作数；并将其加入到node_list中。如果被定义过了，主需要将第三个操作数作为他的从标记即可。判断第三个操作数是否被定义过，如果是的话调用del()函数将其从原来结点中删除，如果没被定义过需要加入到node_list中。最后需要判断一下第一个操作数所在结点是否是临时变量，如果是的话需要将它和最后一个从标记(即第三操作数)交换位置。

**⑩double getcval(OPERAND op); //获得op的常值**

该函数是通过调用符号表，找到常数表获得该操作数的常数值，为两个常数的运算服务的。

**⑪double compare(double a, double b, SIGN s); //两个常数的运算结果**

该函数是为了返回两个常数的运算结果。

**⑫void binaryoperator(SIGN s, OPERAND op1, OPERAND op2, OPERAND op3); //双目运算**

双目运算分为两个都是常数的运算和含变量的运算。

如果两个数都是常数，计算出两个常数的运算结果c。判断c是否已经被定义过了，是的话判断第三个数是否被定义过了，是的话将其从原来结点的从标记中删除，加入到c所在的结点的从标记中；没有就加入到node_list中和c的从标记中。如果c没有被定义，需要建新的结点（加入到NODE中）并加入到node_list中，其从标记为第三操作数。然后判断第三个数是否被定义过，是的话要将其从原来的结点的从标记删除，没有的话要加入到node_list中。

如果是含变量的双目运算，需要判断一下该运算符是否已存在，如果他的左右孩子所在结点分别是操作数1和操作数2的结点，说明该四元式已经有了，只需要将第三个数加入到运算符所在结点的从标记。如果第三个数存在过了需要将其从原来结点的从标记删除，没被定义过要加入到ndoe_list中。如果该运算符没有被定义过，需要建立新的结点，以第三个操作数作为该结点的主标记，并加入到node_list中。然后分为四种情况进行讨论：（1）操作数一已存在，操作数二已存在；（2）操作数一已存在，操作数二不存在；（3）操作数一不存在，操作数二已存在；（4）操作数一不存在，操作数二已存在。上述不存在的要新建节点并加入到node_list中，并将操作数1和操作数2所在结点分别作为当前运算符所在结点的左右孩子。最后需要判断运算符所在结点的主标记是否是临时变量，是的话需要和从标记交换。

**⑬void swap(OPERAND& S1, OPERAND& S2); //交换**

该函数主要是为了当主标记是临时变量时，需要调用该函数将主标记和从标记的内容进行交换。

**⑭string sign_to_string(SIGN sign_enum); //字符转字符串**

该函数主要是为了四元式的运算符输出，因为前端将运算符定义成了枚举型，需要将它变成对应的字符串的形式输出。

**⑮void display(); //输出优化后的四元式**

该函数主要是输出优化后的四元式，需要调用string sign_to_string来获取字符串形式的运算符。



做完优化后感觉自己的逻辑思维还是有所欠缺，需要加以锻炼。虽然之前确定了每个功能的具体流程，但是真正用代码实现时发现很多考虑的还是很不全面，经常是将节点加入到NODE中，又忘记加入到node_list中，操作数1和操作数2与操作数3哪个要从原来标记中删除，哪个不需要删除。总之，就是小错误不断，还有许多非常低级的拼写错误和类型匹配错误。经过此次独立完成优化部分，让我对DAG优化这一方面有了更深的理解，同时也发现了自己长时间没有写较大的项目，对于指针，数组和SQL语句方面都有所生疏。因为对vscode的不熟练，还麻烦了队友通过屏幕共享教自己如何使用vscode进行debug，由于许多的小错误导致自己的运行结果总是出错，将优化与前端链接起来和debug花了近一天的时间，严重拖累了小组的进度。在此也非常感谢在合作过程中队友对自己的帮助和指导！