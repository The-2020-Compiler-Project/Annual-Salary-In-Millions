<h1 align="center">第二次过程报告</h1>

<p align="right">--计算机1803蒙龙-20184364</p>

# 7.4 7.5

#### 1

这两天一直都是在coding做语义分析的部分，一直熬夜早起，今天刚刚把语义分析的部分写完，并将接口进行了链接，将语法错误的bug进行了修复了，逻辑错误依然是存在的，需要继续进行处理。原本是语义分析前端这一块是张翰韬和刘文兴负责的前端的部分，但是由于文法和语义动作是我设计的，我会更加熟悉，再进行语法，所以后来还是我来写，之前张翰韬写过一点语义分析的部分，但是后来几乎都要推翻重写了。

#### 2

语义动作设计到实际的coding还是有点差距的，不管是在语义动作设计的时候有多大的问题，到了实际上手操作的时候才发现很多地方都没有考虑到，基本上是一边编程一边对符号表和文法进行修改。符号表中将之前使用的迭代器全部都换成了整形i来记录对应的位置，因为在实际使用中发现如果push之后迭代器会失效，而且考虑到了优化的时候可能会将删除符号表中的内容的问题，当时在这一块其实还是很头疼的，因为我们用的vector的结构体，token中指向符号表的时候，如何可以在修改符号表之后对token和四元式操作数中的指向符号表的指针进行维护呢？很显然如果用地址或者是迭代器的话都很难维护，实际如果真的要维护的话可能是需要一个一个地进行查找然后再修改，很是困难，后来就直接使用了一个整形来表示符号表中的位置，这样至少再push或者pop之后i依然可以指向对应的位置，但是会带来新的问题，就是它不知道是指向哪一个表中，对于token和operand还好说，固定是指向总表的，但是对于总表中的addr还有类型表中的addr，则需要在原有的基础之上在用一个域来表示它是指向哪一个表的。

```c++
//总表和符号表中的addr的修正
enum TABLE {
    const_int_double,
    const_char,
    const_string,
    lenl,
    ainfl,
    rinfl,
    synbl
    };
struct ADDR{
    TABLE table;
    int position;
};
```

这样修改了符号表之后就要求再后面进行优化的时候，如果删除了变量的话就不能通过erase来消除，要么是不修改函数表，要么是仅仅是把内容清空，这里还不是很明确。

#### 3

同时我将类型表中原本的const_char,const_double,const_int,const_bool,const_string等进行了删除，是否为常数的信息只保留在总表的cat中，不需要在类型表中保存，同时常数表中我将const_int_list和const_double_list进行了整合，统一放在了一个常数表中，这样在填写符号表的时候个更加方便一点，但是类型上依然保留了int和double的区别，，添加了一个函数用来区别常数的int和常数的double，因为在词法分析的时候只是做了一个简单的区别，统一记录为CT，在区别的时候同时考虑了常数处理，词法分析中没有进行常数处理，常数处理放在语法语义分析的地方来做，这是有一点好处的，一是token的结构上可以更加简单和统一，name的域只需要是string就行，第二个好处是不需要用自动机来进行处理，通过atoi()和atof()来进行转化即可，同时可以用两者的大小关系来判断常数的类型，但是对于10.0这种似乎不太明确，这里说一个插曲，当我在测试atoi()和atof()的时候，我转换过后的数值最后多了一个10，而我找其他同学测试没有这个问题，我后来自己换了一个引导文件之后也没有了这个问题。字符常数表中的类型从char换成了string，因为词法分析的时候将字符类型读进来的时候没有去掉'',例如'a',不过问题不大。

#### 4

当数组的元素作为操作数的时候，现在的处理方式是将数组元素当作一个变量放入到符号表中，但是目前还没有先在符号表中查找是否有这个元素了，因为不能进行简单的查找，其中还涉及到了一些作用域的问题，例如内层和外层都定义了数组a，并且都是用了a[3]，这样的话就需要压两个，需要判断作用域的问题，同样，如果外层有一个a3内层有一个a3，应该要区别这两个为不同的变量，现在的处理方式是，对于数组类型的变量，在总表的addr区域指向原本定义的数组a，那么在后续生成四元式或者是目标代码的时候就可以通过访问原本定义的数组找到它的类型和偏移地址，其实一种更加简单的做发是直接不填入符号表中，而是在操作数上开辟一个新的域用来标明这个是数组类型，例如用一个偏移量，对于非数组元素的则设置为0就行，这样就不需要写入符号表中，也可以找到想要的信息，而且没有重复写入符号表的事，不过这是后来才发现的，现在就不改了。

#### 5

今天钟洁同学提醒了我一个问题，就是如何取反临时变量和非临时变量的问题，我们现在临时变量的分配是采用了ti这样，每分配一个i++，当时没有留意到用户定义的变量也可能叫ti，打算后来改成it，这样就不会和标识符重名了，而且钟洁说可以在符号表中再添加一个域用来标记是否为临时变量，其实也行，不过现在还没有改。

#### 6

关于标识符的合法性的问题，添加了两个新的函数，分别是使用的时候变量的合法性和定义的时候变量的合法性，两者都是判断是否已经定义了，但是思路有差别，因为定义是不能再相同的作用域内再次定义，而使用的时候判断是否定义了则可以在不再当前的作用域，而是外层的作用域，也就是在作用域栈中进行查找，如果找到了就返回他在符号表中的地址，没用找到就返回-1，这样可以节省一点运算。并且有一个问题要注意的是不能说找到了就返回，需要优先返回最里层的变量，内层优先。

#### 7

在生成四元式的时候，还有就是生成临时变量的时候，需要判断两种的符号是否吻合，对于相同类型的才可以进行计算或者赋值，添加了一个函数用于判断是否类型匹配，和推导出结果的类型，这两个函数其实可以一起来用，为了在函数返回的时候方便一点，就在类型表中添加了一个wrong_type，这里面还涉及一个思想就是类型之间的变化问题，例如一个整形和一个浮点型相加结果为浮点型，对于逻辑表达式，中bool型和其他类型的转变问题，这个还涉及到文法中的if和while的跳转的条件的问题，和文法设计的关系比较大。

#### 8

今天下午的时候进行第一次的debug，第一次debug的时候报了很多的错误，当时一下把我整懵了，是接口之间的匹配还有文件之间的包含关系的问题，由于我们是用的vscode，没有工程文件，只能单文件编译，这样的话在函数之间的包含关系上就必须很清晰，否在很容易引起重定义的问题，同时发现了不能再.h文件中进行变量的实例化，之前是都将符号表和各种栈的实例化写在了符号表的头文件中，后来全部的改成了放在了语法语义分析的.cpp文件中。下午后面的时候最终是把语法错误全部解决了，下面就是一点点debug改逻辑上的错误。现在总的语法语义分析写了一千多行，其中有一部分的代码时相似的，特别时填符号表还用创建操作数压入对象栈，生成四元式等等，可以考虑之后改成函数。

### 9 

新添加的函数

```c++
TYPEL type_deduction(TVAL tval_1,TVAL tval_2); //用来进行类型的推到

int push_into_synbel_list(SYNBL synbel); //填写符号表并且返回位置

int is_iT_defined(string it_name); //判断标识符是否已经定义了

void push_into_const_int_double_list(OPERAND one,OPERAND two,OPERAND three,SIGN sign);//填写常数表，如果临时变量为常数，则需要额外填写常数表，目前还没有做bool型的

TVAL CT_type_deduction(string str);//判断常数为double还是int类型

bool is_iT_defined_in_current_level(string name);//判断标识符在当前作用域中是否已经定义过

int change_type_to_length(TVAL tval);//获得类型的字节长度
```