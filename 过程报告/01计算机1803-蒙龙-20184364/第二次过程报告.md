<h1 align="center">第二次过程报告</h1>

<p align="right">--计算机1803蒙龙-20184364</p>

# 7.4 7.5

#### 1

这两天一直都是在coding做语义分析的部分，一直熬夜早起，今天刚刚把语义分析的部分写完，并将接口进行了链接，将语法错误的bug进行了修复了，逻辑错误依然是存在的，需要继续进行处理。原本是语义分析前端这一块是张翰韬和刘文兴负责的前端的部分，但是由于文法和语义动作是我设计的，我会更加熟悉，再进行语法，所以后来还是我来写，之前张翰韬写过一点语义分析的部分，但是后来几乎都要推翻重写了。

#### 2

语义动作设计到实际的coding还是有点差距的，不管是在语义动作设计的时候有多大的问题，到了实际上手操作的时候才发现很多地方都没有考虑到，基本上是一边编程一边对符号表和文法进行修改。符号表中将之前使用的迭代器全部都换成了整形i来记录对应的位置，因为在实际使用中发现如果push之后迭代器会失效，而且考虑到了优化的时候可能会将删除符号表中的内容的问题，当时在这一块其实还是很头疼的，因为我们用的vector的结构体，token中指向符号表的时候，如何可以在修改符号表之后对token和四元式操作数中的指向符号表的指针进行维护呢？很显然如果用地址或者是迭代器的话都很难维护，实际如果真的要维护的话可能是需要一个一个地进行查找然后再修改，很是困难，后来就直接使用了一个整形来表示符号表中的位置，这样至少再push或者pop之后i依然可以指向对应的位置，但是会带来新的问题，就是它不知道是指向哪一个表中，对于token和operand还好说，固定是指向总表的，但是对于总表中的addr还有类型表中的addr，则需要在原有的基础之上在用一个域来表示它是指向哪一个表的。

```c++
//总表和符号表中的addr的修正
enum TABLE {
    const_int_double,
    const_char,
    const_string,
    lenl,
    ainfl,
    rinfl,
    synbl
    };
struct ADDR{
    TABLE table;
    int position;
};
```

这样修改了符号表之后就要求再后面进行优化的时候，如果删除了变量的话就不能通过erase来消除，要么是不修改函数表，要么是仅仅是把内容清空，这里还不是很明确。

#### 3

同时我将类型表中原本的const_char,const_double,const_int,const_bool,const_string等进行了删除，是否为常数的信息只保留在总表的cat中，不需要在类型表中保存，同时常数表中我将const_int_list和const_double_list进行了整合，统一放在了一个常数表中，这样在填写符号表的时候个更加方便一点，但是类型上依然保留了int和double的区别，，添加了一个函数用来区别常数的int和常数的double，因为在词法分析的时候只是做了一个简单的区别，统一记录为CT，在区别的时候同时考虑了常数处理，词法分析中没有进行常数处理，常数处理放在语法语义分析的地方来做，这是有一点好处的，一是token的结构上可以更加简单和统一，name的域只需要是string就行，第二个好处是不需要用自动机来进行处理，通过atoi()和atof()来进行转化即可，同时可以用两者的大小关系来判断常数的类型，但是对于10.0这种似乎不太明确，这里说一个插曲，当我在测试atoi()和atof()的时候，我转换过后的数值最后多了一个10，而我找其他同学测试没有这个问题，我后来自己换了一个引导文件之后也没有了这个问题。字符常数表中的类型从char换成了string，因为词法分析的时候将字符类型读进来的时候没有去掉'',例如'a',不过问题不大。

#### 4

当数组的元素作为操作数的时候，现在的处理方式是将数组元素当作一个变量放入到符号表中，但是目前还没有先在符号表中查找是否有这个元素了，因为不能进行简单的查找，其中还涉及到了一些作用域的问题，例如内层和外层都定义了数组a，并且都是用了a[3]，这样的话就需要压两个，需要判断作用域的问题，同样，如果外层有一个a3内层有一个a3，应该要区别这两个为不同的变量，现在的处理方式是，对于数组类型的变量，在总表的addr区域指向原本定义的数组a，那么在后续生成四元式或者是目标代码的时候就可以通过访问原本定义的数组找到它的类型和偏移地址，其实一种更加简单的做发是直接不填入符号表中，而是在操作数上开辟一个新的域用来标明这个是数组类型，例如用一个偏移量，对于非数组元素的则设置为0就行，这样就不需要写入符号表中，也可以找到想要的信息，而且没有重复写入符号表的事，不过这是后来才发现的，现在就不改了。

#### 5

今天钟洁同学提醒了我一个问题，就是如何取反临时变量和非临时变量的问题，我们现在临时变量的分配是采用了ti这样，每分配一个i++，当时没有留意到用户定义的变量也可能叫ti，打算后来改成it，这样就不会和标识符重名了，而且钟洁说可以在符号表中再添加一个域用来标记是否为临时变量，其实也行，不过现在还没有改。

#### 6

关于标识符的合法性的问题，添加了两个新的函数，分别是使用的时候变量的合法性和定义的时候变量的合法性，两者都是判断是否已经定义了，但是思路有差别，因为定义是不能再相同的作用域内再次定义，而使用的时候判断是否定义了则可以在不再当前的作用域，而是外层的作用域，也就是在作用域栈中进行查找，如果找到了就返回他在符号表中的地址，没用找到就返回-1，这样可以节省一点运算。并且有一个问题要注意的是不能说找到了就返回，需要优先返回最里层的变量，内层优先。

#### 7

在生成四元式的时候，还有就是生成临时变量的时候，需要判断两种的符号是否吻合，对于相同类型的才可以进行计算或者赋值，添加了一个函数用于判断是否类型匹配，和推导出结果的类型，这两个函数其实可以一起来用，为了在函数返回的时候方便一点，就在类型表中添加了一个wrong_type，这里面还涉及一个思想就是类型之间的变化问题，例如一个整形和一个浮点型相加结果为浮点型，对于逻辑表达式，中bool型和其他类型的转变问题，这个还涉及到文法中的if和while的跳转的条件的问题，和文法设计的关系比较大。

#### 8

今天下午的时候进行第一次的debug，第一次debug的时候报了很多的错误，当时一下把我整懵了，是接口之间的匹配还有文件之间的包含关系的问题，由于我们是用的vscode，没有工程文件，只能单文件编译，这样的话在函数之间的包含关系上就必须很清晰，否在很容易引起重定义的问题，同时发现了不能再.h文件中进行变量的实例化，之前是都将符号表和各种栈的实例化写在了符号表的头文件中，后来全部的改成了放在了语法语义分析的.cpp文件中。下午后面的时候最终是把语法错误全部解决了，下面就是一点点debug改逻辑上的错误。现在总的语法语义分析写了一千多行，其中有一部分的代码时相似的，特别时填符号表还用创建操作数压入对象栈，生成四元式等等，可以考虑之后改成函数。

#### 9 

新添加的函数

```c++
TYPEL type_deduction(TVAL tval_1,TVAL tval_2); //用来进行类型的推到

int push_into_synbel_list(SYNBL synbel); //填写符号表并且返回位置

int is_iT_defined(string it_name); //判断标识符是否已经定义了

void push_into_const_int_double_list(OPERAND one,OPERAND two,OPERAND three,SIGN sign);//填写常数表，如果临时变量为常数，则需要额外填写常数表，目前还没有做bool型的

TVAL CT_type_deduction(string str);//判断常数为double还是int类型

bool is_iT_defined_in_current_level(string name);//判断标识符在当前作用域中是否已经定义过

int change_type_to_length(TVAL tval);//获得类型的字节长度
```

# 7.6 7.7 7.8

#### 1

在之前写的语义分析的基础之上继续进行debug来对不断的测试和修复bug，经过多次的测试和debug之后，目前对于当前文法的语义分析部分和符号表的填写已经基本上没有问题，当时当我第一次成功输出四元式序列的时候还是非常的激动的，后面就是不断的重复测试工作，修改文件然后再跑一次语义分析，检查结果修改bug，但是在测试的时候其实有一点不方便的地方，就是github上的文件结构上进行debug不方便，因为路径中有中文的课设代码，所以每次运行都需要将文件全部都拷到另外的地方进行修改，修改完之后再将原来的文件进行覆盖，如果可以将文件的目录改成英文的话，就在可以加一个引导文件之后在git的目录下面进行debug。

#### 2

在进行语义分析的debug过程中也发现了原本在设计符号表中的一些不足的地方，特别是在数组处理上，由于之前提到到符号表中使用的是vector，然后索引的方式都是通过一个整形数来标明在表中的位置，这就要求我们不能去删除符号表中的内容，这就导致了符号表中的会存在多余的项，甚至是错误的项，例如是在数组的声明的时候，我们的文法支持在声明数组变量的时候对其进行初始化工作，因此是需要构建一系列的赋值四元式来进行初始化，同时我们也会进行越界的处理，处理方式为在赋值之前先将下一个要初始化的数组元素写入到符号表中，所以会导致最后符号表中多一个多余的项，而且如果是对数组中的所有元素都进行了初始化的话，最后一个元素必定是越界的。其实同理，在进行优化的时候如果删除了某些变量的话也会导致符号表中有多余的元素，这会带来一个问题，就是我们在目标代码生成的时候，不能通过遍历符号表来计算数据段的大小并且来回填符号表中的偏移地址，需要以四元式中的操作数为准，最后优化完之后实际用到哪些符号表中的内容，再来根据这些内容计算数据段大小和偏移地址。

#### 3
后来的分工情况是钟洁负责做优化的部分，然后张翰韬负责做目标代码生成，刘文兴负责做可视化的部分，我继续拓展文法。我原本是想先拓展多一点的语句，包括像goto，select，for等，但是后来发现在词法分析的时候:，for没有做，而且当时词法分析是用自动机的形式做到，里面的状态转移都是是用一个整形数，不好改动，当时负责词法分析的张翰韬同学继续做目标代码生成的模块，当时那一部分是更加重要的，我就没有抽调他出来，后来我就进行函数定义和调用的文法的拓展，主要是对program和F还有其他一些可以推出标识符的地方进行修改，并且完成了文法和语义动作的插入，但是后来时间太紧张了，钟洁和张翰韬做后端比较吃力，我就去支援后端去了，这一块就搁置了下来，但是也已经完成了语义动作的插入，考虑到了如何填写函数表，需要哪些信息，返回值类型的匹配，形参的赋值等等。新添加的翻译文法如下：

1）

     程序--> ①I void main④(){②函数体}③	

     程序--> ①void main④(){②函数体}③

         ①作用域层号的初始化为0，将作用域层号压入到作用域栈里面 初始化当前函数号为1	

         ②作用域层号=1，将作用域层号压入到作用域栈里面

         ③将作用域栈的栈顶元素弹出

         ④填写main函数的符号表和函数表 更新当前函数位置 其中形参表为空 生成MAIN四元式

17)  

     I-->类型①标识符②（H）{③函数体 return 算法表达式}④ I

     I-->?

         ①记录类型

         ②查找标识符是否合法 压入符号表 更新当前符号表的位置 填写部分符号表中的信息  包括函数表 压入总表 生成 F四元式

         ③作用域层号=1，将作用域层号压入到作用域栈里面

         ④将作用域栈的栈顶元素弹出 生成FE四元式

15)

需要传入参数 函数在符号表中的位置

     H-->类型①标识符②变量声明语句_3 

     H-->?

         ①记录类型

         ②在形参表中查找是否重定义 填写形参表 作用域层号固定为1


18）

需要传入参数 函数在符号表中的位置

     变量声明语句3-->,类型①标识符②变量声明语句3

     变量声明语句3-->?
     
         ①记录类型

         ②在形参表中查找是否重定义 填写形参表

2）中添加return

     函数体-->return J⑩；函数体

         ⑩判断对象栈栈顶元素的类型和函数的返回类型是否一致，注意不要弹栈

19) 

     J-->算术表达式子   
      
     J-->?①

         ①判断当前函数的返回类型是否为void 不是void则报错

11）对算术表达式的修改如下

     F-->标识符③D

	 D-->(⑦K)

11）需要传递参数(函数位置)

	 K-->标识符⑧L

	 K-->?⑨

11） 需要传递参数(函数位置 当前填入参数个数)

	 L-->,标识符⑧L

	 L-->?⑩

         ⑦弹出栈顶元素 判断是否为函数类型 获得函数的位置

         ⑧初始化当前填入参数个数为0 当前填入参数个数++  判断当前填入参数个数是否已经超过函数参数个数  生成赋值四元式 

         ⑨判断函数参数个数是否为0

         ⑩判断当前填入参数个数和函数参数个数是否相等

#### 4
在进行添加函数的定义和调用的时候我们比较关系的一个问题就是新的作用域问题，首先函数名字是应当具有最广泛的作用域的，函数名本身是一个标识符，同时函数名的标识符应当是在所有的作用域都具有最高的优先级，同时，不同函数之间可以有同名的变量，那么在我们之前做的判断标识符合法性的时候，包括重定义和是否已经定义都要进行修改，为此，我们新添加了一个机制，函数标号，对于符号表中的用户自定义标号的作用域，还需要考虑函数作用域，是否重定义的问题需要在当前函数域和作用域之外，还需要再函数表中进行查找，判断是否定义的时候需要查找作用域栈，函数表，以及对应的形参表。但是后来去支援后端就没有再继续往下做。

#### 5
钟洁这边之前一直都没有debug过，难以想象她要怎么编写优化的部分，因为优化的逻辑她最清楚，我也不想说推到从新来，所以我就把文件的包含关系都弄好之后，开视频共享一点点手把手教她怎能是用vscode的debug，怎么看变量，怎么单步执行怎么执行到断点，昨晚终于是优化的代码给写好了。但是活跃信息没有填，之前考虑到基本块的嵌套的问题，因为我们的文法支持if中套while，while中套if，while中套while等等，我们原本以为再基本块划分上会有问题，但是后来实际用手写了两个之后发现是按照书上的算法走就行，是没有问题的。

#### 6
张翰韬写的目标代码生成的那一部分是用的伪代码，由于目前没有做函数的定义和调用这一块，那么最令我头疼的内层分配问题就可以解决了，昨晚我就开始进行目标代码生成改写，将它改成汇编语言的，但是汇编语言中需要考虑的内容还是很多，当时用的是伪代码，在很多语法上的细节问题都没有考虑到，而且数据段中是用的是遍历符号表中的内容来通过数据定义伪指令来定义，这是不合理的，无论是命名的合法性，同名但是作用域不同的变量，多余变量，数组等处理都有问题，所以我改写了数据段的逻辑，通过遍历优化后的四元式，根据四元式中操作数来确定到底用到了哪些的空间，再根据大小来填写偏移地址，数组元素的偏移地址需要先处理数组的母，再根据它来求每一个元素的偏于地址，将处理过的符号表中位置记录下来，不再重复处理，最后根据偏移地址来确定数据段的大小，后面生成的目标指令中的操作数全部都用偏移地址的寻址方式。之前张翰韬再写目标代码生成的地方的时候用的一个标记flag来标记是否占有，而没有用RDL，现在需要从新添加，然后每次都释放寄存器，还有其他一些小问题就是目标代码生成中的跳转方式需要根据上一条指令的符号来进行生成，同时考虑到add，sub等等的数据的大小问题。目前目标代码生成中新添加的函数如下

```c++
bool is_processed(int position);//用来判断是否已经填写了偏移地址

int get_element_num(string name);//获取偏移量

int get_length_for_type(TVAL tval);//获取类型的字节大小

void refill_addr();//反填符号表中的偏移地址

void refill_addr_single(OPERAND operand);//反填单个偏移地址

string get_addr_of_operand(OPERAND operand);//获得操作数的偏移地址
```






 


