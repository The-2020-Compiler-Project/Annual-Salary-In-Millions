<h1 align="center">第一次过程报告</h1>

<p align="right">--计算机1803蒙龙-20184364</p>

# 6.26
### 1
统一使用vscode进行开发，初步定为组长创建新建项目再把其他组员加入协作者，初步定下来做类似C语言的编译，先做一个简单的语言将各个部分的功能模块串通起来之后再对文法进行完善
### 2
我们确定了第一代文法中的内容，包括变量定义 整形 浮点 字符型 字符串型，*函数定义和调用表达式（后来删掉了） 算术表达式 赋值表达式 逻辑表达式if+while+goto+label（label和goto删掉了）
### 3
同时我们进行了初步分工：刘文兴 蒙龙：文法设计+语法分析+语义分析+中间代码生成，其中文法设计 ：文法+翻译文法，张翰韬 钟洁：词法分析+优化+目标代码生成

# 6.29
### 1
今天是第一次上机，我们重新进行了一次分工，现在的分工情况是我和钟洁同学负责后端，包括优化和目标代码生成的部分，目标代码使用汇编语义进行。前端部分由张翰韬和刘文兴两位同学负责，包括词法分析，语法分析和语义分析。文法主要是我和张翰韬负责设计。
### 2
今天经过语言讨论我们初步确定了文法的设计，文法中的第一代的内容里面暂时先没有了函数的定义和调用，只有main的，也去掉了goto和label。原本是将文法的各个部分分给每个同学来做的，但是张翰韬同学似乎一下子就写出来了。但是后来发现文法中有很大的第一部分不是LL1文法，后来我花了很大的精力来从新改写文法。
### 3
晚上我们进行了词法分析的和符号表的讨论和初步的开发工作，主要是由张翰韬同学来做，在语法分析中调用词法分析的来获得一个一个TOKEN，但是现在的做法是先词法分析得到所有的TOKEN，放在一个vector里面，然后再一个个地读，如果是每调用一次再读一个TOKEN的方式也可以，但是返回的时候文件流不能关闭，就是源文件的文件流需要在语法分析中打开。但是现在采用的方式虽然是一次性生成完所有的TOKEN，但是也可以一个一个地读。
### 4
TOKEN的中包含的内容为一个类型和name，我记得但是课上讲过虽然现在是name但是实际应该是指向符号表中的指针，但是在词法分析时候似乎不能完成完整的符号表，关键字表和界符表可以完成，但是含类型表函数表总表的内容应该是在进行语法分析的时候再来进行确定会方便一点，现在暂定是TOKEN进行初步类别标明为关键字 标识符 界符和常数，但还没完成，等张把代码推上了我们在来一次看

# 6.30
### 1
我和张翰韬初步完成了文法的设计，我们原本在29号晚上完成了文法的初步设计，但是当时没用留意到有些地方不是LL1的，这个问题我是有责任的，设计文法的时候有一些很明显的错误没有意识到，我们后来就直接开始设计翻译文法，完成了语义动作的插入工作，但是还没有很规范的系统地写出来，但是后来在实际做递归下降子程序的时候发现文法有问题，发现有些地方不是LL1的后来花了挺多时间来更改这一部分，对开发的进度影响还是挺大的。
### 2
同时我完成了符号表的设计，在课件的符号表的基础上添加了标识符表，用来语法分析时候判断重复定义以及赋值的时候类型是否统一，但是要注意作用域，和队友商量了之后任务符号表的主要的填写还是在语法分析中进行，在词法分析的时候生成的TOKEN只做简单的分类。符号表的具体填写在做语法分析的时候再来插入会方便很多。
```c++
enum CAT { f,
    c,
    t,
    d,
    v,
    vn,
    vf };
//按照实际进行修改
enum TVAL { Int,
    Double,
    String,
    Char,
	Bool,
	Const_int,
	Const_double,
	Const_char,
	Const_string,
    Array,
	};//这部分是为了填符号表的时候确定相应的类型
//类型表
struct TYPEL {
    TVAL tval;
    void* tpoint;
};
vector<TYPEL> typel_list;

//各个常数表
vector<int> const_int_list;
vector<int>::iterator const_int_list_it =const_int_list.begin();//便于索引常数表中的内容
vector<float> const_float_list;
vector<char> const_char_list;
vector<string> const_string_list;

//总表
struct SYNBL {
    string name;
    TYPEL TYPE;
    CAT cat;
    int level; //作用域标号
    int offset_add;//偏移地址
    void* addr; //改为偏移地址 注意数组类型的偏移地址有不确定性
};
vector<SYNBL> synbel_list;
vector<SYNBL>::iterator synbel_it = synbel_list.begin();//用来标记符号表填入的当前位置，便符号表的管理
//先++synbel_it，再压入符号表

//长度表，自定义类型需要指过去
vector<int> LENL;

//数组表
struct AINFL {
    int low;
    int up;
    TYPEL* ctp;
    int clen;
};
vector<AINFL> ainfl_list;

//结构表 暂时用不到
struct RINFL {
    string name;
    int off;
    TYPEL* tp;
};
vector<RINFL> rinfl_list;

//形参表
struct FPL {
    string name;
    TYPEL* tp;
    CAT cat;
    int level; //对应活动记录中的第几层
    int off; //对应的偏移地址
};
vector<FPL> fpl_list;

//函数表
struct PFINFL {
    int level;
    int off;
    int FN;
    long ENTRY;
    FPL* fpl_pointer;
    int data_long; //该函数中需要开辟的空间的大小 为了目标代码生成服务
};
vector<PFINFL> pfinfl_list;

//标识符表 为了方便判断是否重定义以及类型是否匹配 额外设立一个标识符表
struct IDENTIFY {
    string name;
    TYPEL* tp;
    int level; //当前的作用域的层数 0为全局作用域 1为main作用域 当重作用域中返回的时候需要删除表
};

//已分配作用域标号
int current_level=0;
//作用域栈
vector <int> current_level_stcak;//作用域栈，用来存储作用域。
vector <int>::iterator level_it =current_level_stcak.begin();//用来表示栈顶，便于释放元素
//四元式符号
enum SIGN {
    add,
    sub,
    multi,
    div_,
    equal,
    not_equal,
    larger,
    smaller,
    larger_equal,
    smaller_equal,
    and_,
    or_
};
//操作符栈
stack<SIGN> sign_stack;

//操作数结构
struct OPERAND {
    string name;
    vector<SYNBL>::iterator pointer;//配合着synbel_it,共同确定相应的符号表的位置
};
//对象栈
stack<OPERAND> operand_stack;

//四元式结构体
struct QUATERNION {
    SIGN sign;
    OPERAND operand_1;
    OPERAND operand_2;
    OPERAND operand_3;
};
vector<QUATERNION> quaternion_list;
```

### 3
如果之后考虑到函数的定义和调用的话，变量实际上存放的地方应该是在活动记录中，课件上说活动记录是内存单元的一个映射，但是我感觉实际存放在活动记录中也未尝不可，或者说内存中应当由活动记录的结构，活动记录应该是在运行过程中分配，因为不知道会调用多少次，如果一部分事先已经知道了会调用多少次的话就可以提前分配好内存，计算出函数的所有的需要开辟多少的内存空间，但是如果是运行过程中分配的话是不是要在四元式和目标代码生成中生成维护内存的四元式或指令，但是汇编语言并没有动态分配内存的方法，最坏情况下要写一个内存管理的机制。
### 4
词法分析基本上完成了，并且也开始了语法分析的工作。

# 7.1
### 1
进一步完成了文法设计，完成了LL1的修改而且完成了语义动作的设计，翻译文法完成，目前我的工作主要是完成了翻译文法的设计。同时对之前的符号表进行了修改，在之前的基础上在符号表总表中添加了当前作用域标号，为了语义分析服务添加了符号栈，对象栈，作用域标号栈三个栈，符号栈中存储四元式符号，对象栈中为操作数，但是不仅仅是操作数，过程中各种数值都会存储在对象栈中。也完成了四元式的设计。符号栈，对象栈主要是为了四元式生成服务的，而作用域栈是为了变量重定义以及未定义就是用的时候判断用到，设计方式大概是遇到{分配作用域标号+1并压栈}作用域栈弹栈。语义动作中不仅仅是生成四元式，其实很大的一部分工作是用来维护符号表以及其他的一些工作。反而感觉生成四元式的动作设计思想上是很直来直去的。其他的反而需要一些技巧。

需要三个辅助栈，符号栈，对象栈，作用域栈，以及一个整形记录当前的作用域层号，压入符号栈中的元素必须是指向符号表的一个元素，需要记录它的偏移地址以及它的类型，四元式中的操作数应该也是这样的结构体。
***
1） 

     程序-->①void main (){②函数体}③	

①作用域层号的初始化为0，将作用域层号压入到作用域栈里面	

②作用域层号+1，将作用域层号压入到作用域栈里面

③将作用域栈的栈顶元素弹出
***
2） 

     函数体-->类型 变量声明语句 函数体	

     函数体-->标识符① A 函数体	

     函数体-->if(表达式  )②{③函数体④}⑥ B函数体

     函数体-->While⑦(表达式)⑧{③函数体⑨}⑥ 函数体

     函数体-->？

①在符号表中查找是否已经定义了，若没有定义则报错，报错为未定义，构建操作数对象，压入到对象栈中

②弹出对象栈作为操作数，生成if四元式，

③作用域层号+1，将作用域层号压入到作用域栈里面

④生成ie四元式

⑥将作用域栈的栈顶元素弹出

⑦生成wh四元式

⑧弹出对象栈栈顶元素作为调整的条件，生成do四元式

⑨生成we四元式

***
14）

     B-->else①{②函数体 }③	

     B-->?
①生成else四元式	

②作用域层号+1，将作用域层号压入到作用域栈里面

③将作用域栈的栈顶元素弹出
***
12）

     A-->[①算术表达式]②赋值语句 

     A-->赋值语句					
①弹出对象栈，判断是否为数组类型，若不为数组类型则报错，若为数组类型则保存起来。

②弹出对象栈栈顶元素作为数组的标号，填写符号表，构建操作数对象，压入对象栈中。
***
需要传入参数(类型)

3）

     变量声明语句-->标识符①C ；  

①在符号表中查找，看是否存在同名的标识符并且作用域相同，若存在说明发生重定义错误，进行错误处理。

***
需要传入参数(标识符，类型)

13） 

     C-->①变量声明语句_1

     C-->[算术表达式]③变量声明语句_2

①填写符号表，构建操作数对象，将标识符压入对象栈中。	

②弹出对象栈栈顶元素作为数组的大小，填写符号表中的总表以及标识符表，构建操作数对象，将标识符压入对象栈中。	   
***
4）

     类型--> int|char|bool|string|double
***
需要传入参数(类型) 

5)  

     变量声明语句_1--> ,②标识符①变量声明语句_1	

     变量声明语句_1-->=表达式③		

     变量声明语句_1-->?②	

①在符号表中查找，看是否存在同名的标识符并且作用域相同，若存在说明发生重定义错误，进行错误处理。若正常则填写符号表中的总表以及标识符表，将标识符压入对象栈中。

②弹出对象栈栈顶元素

③弹出对象栈栈顶元素作为操作数，弹出次栈顶元素作为赋值的对象，生成赋值四元式。
***
需要传入参数(类型) 

6）

     变量声明语句_2-->,②标识符①[算数表达式]③变量声明语句_2	

     变量声明语句_2-->=④{表达式⑤ 数组初始化}	

     变量声明语句_2-->? 		

②弹出对象栈栈顶元素

①在符号表中查找，看是否存在同名的标识符并且作用域相同，若存在说明发生重定义错误，进行错误处理。若正确则记录标识符的名字

③弹出对象栈栈顶元素作为数组的大小，判断类型是否为常数，若不为常数则报错，填写符号表中的总表以及标识符表，构建操作数对象，将标识符压入对象栈中。

④弹出对象栈栈顶元素，获得需要初始化的数组A的下标以及偏移地址和类型，通过一个整形 i 来记录当前初始化的个数，初始为0，将A[i]填写符号表，构建操作数类型，压入对象栈。

⑤弹出对象栈的栈顶元素作为赋值的内容，弹出对象栈的次栈顶作为赋值的对象，判断两个操作数的类型是否相同，构建赋值四元式。i++，将A[i]填写符号表，构建操作数类型，压入对象栈。
***
需要传入参数(类型，数组最大值，当前值i) 

7）

     数组初始化-->,①表达式②数组初始化	

     数组初始化-->？③	

①判断是否超过了数组的最大范围 i是否>=数组最大值

②弹出对象栈的栈顶元素作为赋值的内容，弹出对象栈的次栈顶作为赋值的对象，判断两个操作数的类型是否相同，构建赋值四元式。i++，将A[i]填写符号表，构建操作数类型，压入对象栈。

③弹出对象栈中的多余的一个内容
				
***
8）

     赋值语句--> =表达式①;

弹出对象栈的栈顶元素作为赋值的内容，弹出对象栈的次栈顶作为赋值的对象，判断两个操作数的类型是否相同，构建赋值四元式。

***
9）

     表达式-->算数表达式 逻辑表达式

     表达式-->字符常量①

     表达式-->字符串常量①

①填写符号表，构建操作数对象，压入对象栈
***
10）

     逻辑表达式--> >①算数表达式②

     逻辑表达式--> <①算数表达式②

     逻辑表达式--> <①算数表达式②

     逻辑表达式--> <=①算数表达式②

     逻辑表达式--> &&①算数表达式②

     逻辑表达式--> ||①算数表达式②

     逻辑表达式--> !=①算数表达式②

     逻辑表达式-->?

①逻辑符号保存到符号栈中

②弹出对象栈的栈顶元素和次栈顶元素，栈顶元素作为操作数2，次栈顶元素作为操作数1。判断两个操作数是否是同类型的，不是则错误处理，弹出符号栈作为符号，生成四元式，将四元式结果压入到操作数栈
***
11）

     E--> T E1

     E1--> +①T②E1 

     E1-->-①T②E1

     E1-->?

     T--> F T1

     T1--> *①F②T1 

     T1-->/①F②T1

     T1-->?

     F-->标识符③D

     D-->[算术表达式]④

     D-->?⑤

     F-->常数⑤

      F-->(E)

①将操作符保存到符号栈中。

②对象栈弹出栈顶元素作为第二个操作数和对象栈弹出次栈顶元素作为第一个操作数，符号栈弹出栈顶元素作符号，在符号表中添加新的临时变量，生成四元式并将结果操作数（新生成的临时变量）存放入对象栈中，对象栈中的内容要需要是操作数结构体，临时变量的类型通过操作数的类型进行推出。

③查表看当前标识符是否已经定义过，注意作用域问题，若没有定义进行报错处理，注意不要压入操作数栈，需要判断是否为数组类型再构建操作数，在查找是否定义过的时候记录是否为数组类型。

④弹出对象栈栈顶元素作为数组的下标，填写符号表，符号表中addr？如何设置，建立操作数对象并且压入到对象栈。

⑤填写符号表，构建操作数对象，压入对象栈。
***
### 2
原本我们在设计TOKEN的时候结构是很简单的，仅仅是一个类码一个name，而课上说的是要指向符号表的，而在词法分析的时候难以建立完整的符号表，而当我自己设计语义动作的时候才感觉到这个的必要性，因为在生成四元式的时候，无论是判断是否重定义还是赋值语句判断类型是否吻合，推到中间变量的类型，数组是否越界以及之后目标代码生成的时候找地址等等信息都需要找符号表，所以后来是再一次设计了一个操作数结构体，指向符号表。
### 3
在符号表的设计上，在数组的设计中，目前我们是将例如A[1]这样的内容也放到了符号表里面，单独看成是一个变量来操作，不过例如在对数组进行初始化的时候，就会在符号表中生成很大的一块空间，之后看看能不能优化一下。
### 4
在设计语义动作的时候我一开始是在if和while语句的推到时候设计四元式的时候也想来一些回填的内容，就是在四元式设计的时候就考虑到跳转到哪一个四元式，不过后来还是弃用了，主要是两个问题，一个是优化的时候如果删除了中间的一部分的话，要维护跳转到那条语句就很麻烦，二则是实际目标代码生成的时候一条四元式可能会生成几条语句，所以回填的工作放在后端还是有它的道理的。
### 5
在进行语义动作设计的时候，我才真切的感觉到 四元式 符号表 语义动作 文法 四者是需要高度统一配合的，牵一发动全身。

# 7.2
### 1
今天主要是讲我之前写的语义动作的部分和队友们进行了详细的讲解，对符号表中的部分内容进行了进一步的修改，包括将作用域栈从stack改成了vector类型，总表中添加了偏移地址的域，但是偏移地址的域的维护不需要在语义分析的过程中填写，因为当进行优化的时候将一部分的变量删除了之后可能会改变它的偏移地址，添加了长度表，但是现在我们其实并没有自定义的数据类型，所以长度表基本上还用不到。
### 2
将词法分析和语法分析串了起来，对词法分析和语法分析进行了Debug，词法分析中发现还存在一些bug，文件的末尾需要使用一个#来标记结束，而且#必须是位于文件的最后一行的空行，但是如果不是空行的话读取会出现问题，猜测原因是在读取文件的时候出现了问题，但是如果现在改动的话需要改自动机，所以现在还是先不改了。
### 3
今天就函数调用时候内存分配问题问了两个老师，活动记录其实是内存中的映射，本身是虚的结构，在实际的内存中不一定严格地按照活动记录的结构来存储，而且严格按照课本上的数据结构维护内存空间是困难的，在某些情况下函数的调用次数是不清晰的，这种情况下就无法提前分配好内存，只能是在运行过程中来进行维护内存或者活动记录，但是汇编语义本身的是没有动态内存分配的说法的，要么是调用系统的api要么是自己写一个内存管理的模块，实际上对于内存管理的这个概念应该是在操作系统之上的范围内才有意义，分配的目的是为了防止别的程序占用，但是对于汇编语言这种低级语言来说不存在占用的这一个说法，因为它可以之间对内存中的单元进行读写，只是这部分内存实际上并不是动态分配的，而是预留出来的。有的时候程序运行时包括，会提示栈溢出，就是指这部分预分配空间不够了。内存管理如果你没有太多动态内存的分配，可以简单写一个。但是这部分想要弄好，还是比较麻烦的。可以考虑先处理一些预定义好类型的变量的存储，动态存储的部分可以作为第二阶段的内容推进。